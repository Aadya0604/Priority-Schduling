<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Priority Planner - CPU Scheduling Simulator</title>
    <style>
* {
    margin: 0;
    padding: 0;
    box-sizing: border-box;
}

body {
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    background: linear-gradient(135deg, #1e3c72 0%, #2a5298 50%, #7e22ce 100%);
    min-height: 100vh;
    padding: 20px;
    color: #fff;
}

.container {
    max-width: 1400px;
    margin: 0 auto;
}

.header {
    text-align: center;
    margin-bottom: 30px;
}

.header h1 {
    font-size: 3rem;
    background: linear-gradient(45deg, #fbbf24, #f59e0b, #ef4444);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    margin-bottom: 10px;
    text-shadow: 0 0 30px rgba(251, 191, 36, 0.3);
}

.header p {
    font-size: 1.2rem;
    opacity: 0.9;
}

.game-stats {
    display: flex;
    justify-content: center;
    gap: 30px;
    margin-bottom: 20px;
    flex-wrap: wrap;
}

.stat-badge {
    background: rgba(255,255,255,0.1);
    backdrop-filter: blur(10px);
    padding: 15px 30px;
    border-radius: 15px;
    border: 2px solid rgba(255,255,255,0.3);
    display: flex;
    align-items: center;
    gap: 10px;
    font-size: 1.2rem;
    animation: fadeIn 0.5s;
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-10px); }
    to { opacity: 1; transform: translateY(0); }
}

.stat-badge .icon {
    font-size: 2rem;
}

.stat-badge .value {
    font-weight: 700;
    color: #fbbf24;
}

.level-progress {
    background: rgba(0,0,0,0.3);
    height: 30px;
    border-radius: 15px;
    overflow: hidden;
    margin-bottom: 20px;
    border: 2px solid rgba(255,255,255,0.2);
}

.level-bar {
    height: 100%;
    background: linear-gradient(90deg, #10b981, #fbbf24, #ef4444);
    transition: width 0.5s;
    display: flex;
    align-items: center;
    justify-content: center;
    font-weight: 700;
}

.mode-selector {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 30px;
}

.mode-btn {
    padding: 12px 30px;
    border: 2px solid rgba(255,255,255,0.3);
    background: rgba(255,255,255,0.1);
    color: white;
    border-radius: 10px;
    cursor: pointer;
    font-weight: 600;
    transition: all 0.3s;
}

.mode-btn:hover {
    background: rgba(255,255,255,0.2);
    transform: translateY(-2px);
}

.mode-btn.active {
    background: linear-gradient(45deg, #f59e0b, #ef4444);
    border-color: #ef4444;
    box-shadow: 0 5px 20px rgba(239, 68, 68, 0.4);
}

.main-grid {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 20px;
    margin-bottom: 20px;
}

.panel {
    background: rgba(255, 255, 255, 0.1);
    backdrop-filter: blur(10px);
    border-radius: 15px;
    padding: 25px;
    border: 1px solid rgba(255,255,255,0.2);
}

.panel h2 {
    margin-bottom: 20px;
    font-size: 1.5rem;
    display: flex;
    align-items: center;
    gap: 10px;
}

.input-grid {
    display: grid;
    grid-template-columns: 2fr 1fr 1fr 1fr;
    gap: 10px;
    margin-bottom: 15px;
}

.input-group {
    display: flex;
    flex-direction: column;
    gap: 5px;
}

.input-group label {
    font-size: 0.85rem;
    opacity: 0.8;
}

input, select {
    padding: 10px;
    border: 2px solid rgba(255,255,255,0.2);
    background: rgba(255,255,255,0.1);
    color: white;
    border-radius: 8px;
    font-size: 1rem;
}

input::placeholder {
    color: rgba(255,255,255,0.5);
}

input:focus, select:focus {
    outline: none;
    border-color: #f59e0b;
    background: rgba(255,255,255,0.15);
}

.btn {
    padding: 12px 25px;
    border: none;
    border-radius: 10px;
    font-weight: 600;
    cursor: pointer;
    transition: all 0.3s;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.btn-add {
    background: linear-gradient(45deg, #10b981, #059669);
    color: white;
    width: 100%;
    margin-top: 10px;
}

.btn-add:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(16, 185, 129, 0.4);
}

.btn-start {
    background: linear-gradient(45deg, #f59e0b, #ef4444);
    color: white;
    font-size: 1.1rem;
}

.btn-start:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 20px rgba(239, 68, 68, 0.4);
}

.btn-start:disabled {
    opacity: 0.5;
    cursor: not-allowed;
}

.btn-reset {
    background: rgba(255,255,255,0.2);
    color: white;
}

.task-queue {
    display: flex;
    flex-direction: column;
    gap: 10px;
    max-height: 400px;
    overflow-y: auto;
}

.task-card {
    background: rgba(255,255,255,0.1);
    border: 2px solid rgba(255,255,255,0.2);
    border-radius: 10px;
    padding: 15px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    animation: slideIn 0.3s;
}

@keyframes slideIn {
    from { opacity: 0; transform: translateX(-20px); }
    to { opacity: 1; transform: translateX(0); }
}

.task-card.executing {
    border-color: #f59e0b;
    background: rgba(245, 158, 11, 0.2);
    box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
}

.task-card.completed {
    opacity: 0.6;
    border-color: #10b981;
    animation: taskComplete 0.5s;
}

@keyframes taskComplete {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

.task-info h3 {
    font-size: 1.1rem;
    margin-bottom: 5px;
}

.task-meta {
    display: flex;
    gap: 15px;
    font-size: 0.9rem;
    opacity: 0.8;
}

.priority-badge {
    padding: 5px 12px;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 700;
}

.priority-1 { background: linear-gradient(45deg, #ef4444, #dc2626); }
.priority-2 { background: linear-gradient(45deg, #f59e0b, #d97706); }
.priority-3 { background: linear-gradient(45deg, #fbbf24, #f59e0b); }
.priority-4 { background: linear-gradient(45deg, #10b981, #059669); }
.priority-5 { background: linear-gradient(45deg, #3b82f6, #2563eb); }

.gantt-container {
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    padding: 20px;
    min-height: 200px;
    position: relative;
    overflow-x: auto;
}

.gantt-chart {
    display: flex;
    align-items: center;
    min-height: 150px;
    position: relative;
}

.gantt-bar {
    height: 60px;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: 600;
    border-radius: 5px;
    border: 2px solid rgba(255,255,255,0.3);
    position: relative;
    animation: barGrow 0.5s;
}

@keyframes barGrow {
    from { width: 0; }
}

.gantt-bar.current {
    animation: pulse 1s infinite;
}

@keyframes pulse {
    0%, 100% { box-shadow: 0 0 20px rgba(245, 158, 11, 0.5); }
    50% { box-shadow: 0 0 40px rgba(245, 158, 11, 0.8); }
}

.time-label {
    position: absolute;
    bottom: -25px;
    font-size: 0.8rem;
    opacity: 0.7;
}

.metrics-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 15px;
}

.metric-card {
    background: rgba(255,255,255,0.1);
    padding: 20px;
    border-radius: 10px;
    text-align: center;
    border: 2px solid rgba(255,255,255,0.2);
    transition: all 0.3s;
}

.metric-card:hover {
    transform: translateY(-5px);
    border-color: #fbbf24;
}

.metric-value {
    font-size: 2.5rem;
    font-weight: 700;
    background: linear-gradient(45deg, #fbbf24, #f59e0b);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
}

.metric-label {
    font-size: 0.9rem;
    opacity: 0.8;
    margin-top: 5px;
}

.cpu-status {
    display: flex;
    align-items: center;
    gap: 15px;
    padding: 15px;
    background: rgba(0,0,0,0.3);
    border-radius: 10px;
    margin-bottom: 20px;
}

.cpu-icon {
    font-size: 3rem;
}

.cpu-icon.running {
    animation: rotate 2s linear infinite;
}

@keyframes rotate {
    from { transform: rotate(0deg); }
    to { transform: rotate(360deg); }
}

.controls {
    display: flex;
    gap: 15px;
    justify-content: center;
    margin-top: 20px;
}

.empty-state {
    text-align: center;
    padding: 50px;
    opacity: 0.6;
}

.achievement-popup {
    position: fixed;
    top: 20px;
    right: 20px;
    background: linear-gradient(45deg, #fbbf24, #f59e0b);
    padding: 20px;
    border-radius: 15px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    animation: achievementSlide 0.5s;
    z-index: 1000;
    max-width: 300px;
}

@keyframes achievementSlide {
    from { transform: translateX(400px); opacity: 0; }
    to { transform: translateX(0); opacity: 1; }
}

.achievement-popup h3 {
    font-size: 1.5rem;
    margin-bottom: 10px;
}

.combo-meter {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 4rem;
    font-weight: 900;
    color: #fbbf24;
    text-shadow: 0 0 20px rgba(251, 191, 36, 0.8);
    animation: comboAppear 1s;
    pointer-events: none;
    z-index: 999;
}

@keyframes comboAppear {
    0% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
    50% { transform: translate(-50%, -50%) scale(1.2); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(0); opacity: 0; }
}

@media (max-width: 1024px) {
    .main-grid {
        grid-template-columns: 1fr;
    }
    
    .input-grid {
        grid-template-columns: 1fr;
    }
    
    .metrics-grid {
        grid-template-columns: repeat(2, 1fr);
    }
}
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>‚ö° Priority Planner</h1>
            <p>CPU Scheduling Simulator | Manage Tasks Like an Operating System</p>
        </div>

        <div class="panel" style="margin-bottom: 20px;">
            <h2>üìö How Priority Scheduling Works</h2>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-top: 15px;">
                <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                    <h3 style="color: #fbbf24; margin-bottom: 10px;">üéØ Priority Rules</h3>
                    <ul style="line-height: 1.8; opacity: 0.9;">
                        <li><strong>Lower number = Higher priority</strong></li>
                        <li>Priority 1 (Highest) executes first</li>
                        <li>Priority 5 (Lowest) executes last</li>
                        <li>Tasks with same priority follow FCFS</li>
                    </ul>
                </div>
                <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                    <h3 style="color: #f59e0b; margin-bottom: 10px;">üîÑ Execution Modes</h3>
                    <ul style="line-height: 1.8; opacity: 0.9;">
                        <li><strong>Non-Preemptive:</strong> Once started, task runs until completion</li>
                        <li><strong>Preemptive:</strong> Higher priority task can interrupt current task</li>
                        <li>Context switches occur when switching between tasks</li>
                    </ul>
                </div>
            </div>
            <div style="background: linear-gradient(45deg, #ef4444, #f59e0b); padding: 20px; border-radius: 10px; margin-top: 15px; text-align: center;">
                <h3 style="font-size: 1.3rem; margin-bottom: 10px;">‚ö†Ô∏è Key Concept</h3>
                <p style="font-size: 1.1rem; font-weight: 600;">Tasks with Priority 5 (Lowest Priority) will be executed LAST, after all higher priority tasks (1-4) have completed!</p>
            </div>
            <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.05); border-radius: 10px; border-left: 4px solid #10b981;">
                <p style="opacity: 0.9; line-height: 1.6;">
                    <strong>Example:</strong> If you have tasks with priorities P1, P3, and P5 arriving at the same time, 
                    the CPU will execute P1 first, then P3, and finally P5. This is called <strong>Priority Scheduling</strong> - 
                    a CPU scheduling algorithm where each task is assigned a priority, and the CPU allocates resources to the highest priority task first.
                </p>
            </div>
        </div>

        <div class="game-stats">
            <div class="stat-badge">
                <span class="icon">‚≠ê</span>
                <div>
                    <div>Level <span class="value" id="level">1</span></div>
                </div>
            </div>
            <div class="stat-badge">
                <span class="icon">üèÜ</span>
                <div>
                    <div>Score: <span class="value" id="score">0</span></div>
                </div>
            </div>
            <div class="stat-badge">
                <span class="icon">üî•</span>
                <div>
                    <div>Streak: <span class="value" id="streak">0</span></div>
                </div>
            </div>
            <div class="stat-badge">
                <span class="icon">‚úÖ</span>
                <div>
                    <div>Tasks: <span class="value" id="tasksCompleted">0</span></div>
                </div>
            </div>
        </div>

        <div class="level-progress">
            <div class="level-bar" id="levelBar" style="width: 0%">
                <span id="xpText">0 / 100 XP</span>
            </div>
        </div>

        <div class="mode-selector">
            <button class="mode-btn active" data-mode="non-preemptive">Non-Preemptive</button>
            <button class="mode-btn" data-mode="preemptive">Preemptive</button>
        </div>

        <div class="main-grid">
            <div class="panel">
                <h2>üìù Task Input Panel</h2>
                <div class="input-grid">
                    <div class="input-group">
                        <label>Task Name</label>
                        <input type="text" id="taskName" placeholder="e.g., Complete Report">
                    </div>
                    <div class="input-group">
                        <label>Arrival Time</label>
                        <input type="number" id="arrivalTime" value="0" min="0">
                    </div>
                    <div class="input-group">
                        <label>Burst Time</label>
                        <input type="number" id="burstTime" value="5" min="1">
                    </div>
                    <div class="input-group">
                        <label>Priority (1=High)</label>
                        <input type="number" id="priority" value="1" min="1" max="5">
                    </div>
                </div>
                <div class="input-group">
                    <label>Category</label>
                    <select id="category">
                        <option value="Work">üíº Work</option>
                        <option value="Study">üìö Study</option>
                        <option value="Personal">üè† Personal</option>
                        <option value="Urgent">üî• Urgent</option>
                    </select>
                </div>
                <button class="btn btn-add" id="addTaskBtn">Add Task to Queue (+10 XP)</button>

                <div style="margin-top: 30px;">
                    <h2>üìä Current Task Queue</h2>
                    <div class="task-queue" id="taskQueue">
                        <div class="empty-state">No tasks in queue. Add tasks above!</div>
                    </div>
                </div>
            </div>

            <div class="panel">
                <div class="cpu-status">
                    <div class="cpu-icon" id="cpuIcon">üñ•</div>
                    <div>
                        <h3 id="cpuStatus">CPU Idle</h3>
                        <p id="currentTask">Waiting for tasks...</p>
                    </div>
                </div>

                <h2>üìà Gantt Chart</h2>
                <div class="gantt-container">
                    <div class="gantt-chart" id="ganttChart">
                        <div class="empty-state">Start execution to see timeline</div>
                    </div>
                </div>

                <div class="controls">
                    <button class="btn btn-start" id="startBtn">‚ñ∂ Start Execution</button>
                    <button class="btn btn-reset" id="resetBtn">üîÑ Reset</button>
                </div>
            </div>
        </div>

        <div class="panel">
            <h2>üìä Performance Metrics</h2>
            <div class="metrics-grid">
                <div class="metric-card">
                    <div class="metric-value" id="avgWaitTime">0</div>
                    <div class="metric-label">Avg Wait Time</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="avgTurnaround">0</div>
                    <div class="metric-label">Avg Turnaround</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="contextSwitches">0</div>
                    <div class="metric-label">Context Switches</div>
                </div>
                <div class="metric-card">
                    <div class="metric-value" id="cpuUtilization">0%</div>
                    <div class="metric-label">CPU Utilization</div>
                </div>
            </div>
        </div>

        <div class="panel" id="executionOrderPanel" style="display: none;">
            <h2>üéØ Task Execution Order Summary</h2>
            <div style="background: rgba(0,0,0,0.3); padding: 20px; border-radius: 10px;">
                <h3 style="color: #fbbf24; margin-bottom: 15px;">Tasks were executed in the following priority order:</h3>
                <div id="executionOrderList" style="display: flex; flex-direction: column; gap: 15px;">
                </div>
            </div>
            <div style="margin-top: 20px; padding: 15px; background: linear-gradient(45deg, #10b981, #059669); border-radius: 10px; text-align: center;">
                <p style="font-size: 1.1rem; font-weight: 600;">‚úÖ Lower priority numbers (P1) executed before higher priority numbers (P5)</p>
            </div>
        </div>
    </div>

    <script>
class GameManager {
    constructor() {
        this.score = 0;
        this.level = 1;
        this.xp = 0;
        this.streak = 0;
        this.tasksCompleted = 0;
        this.xpToNextLevel = 100;
    }

    addXP(amount) {
        this.xp += amount;
        this.score += amount;
        
        if (this.xp >= this.xpToNextLevel) {
            this.levelUp();
        }
        
        this.updateUI();
    }

    levelUp() {
        this.level++;
        this.xp = this.xp - this.xpToNextLevel;
        this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5);
        this.showAchievement(`Level Up! üéâ`, `You've reached Level ${this.level}!`);
        this.addXP(50); // Bonus XP for leveling up
    }

    completeTask() {
        this.tasksCompleted++;
        this.streak++;
        const baseXP = 20;
        const streakBonus = Math.min(this.streak * 5, 50);
        const totalXP = baseXP + streakBonus;
        this.addXP(totalXP);
        
        if (this.streak % 5 === 0) {
            this.showCombo(`${this.streak}x COMBO!`);
            this.showAchievement(`Combo Master! üî•`, `${this.streak} tasks in a row!`);
        }
        
        this.updateUI();
    }

    resetStreak() {
        this.streak = 0;
        this.updateUI();
    }

    updateUI() {
        document.getElementById('score').textContent = this.score;
        document.getElementById('level').textContent = this.level;
        document.getElementById('streak').textContent = this.streak;
        document.getElementById('tasksCompleted').textContent = this.tasksCompleted;
        
        const progress = (this.xp / this.xpToNextLevel) * 100;
        document.getElementById('levelBar').style.width = progress + '%';
        document.getElementById('xpText').textContent = `${this.xp} / ${this.xpToNextLevel} XP`;
    }

    showAchievement(title, message) {
        const popup = document.createElement('div');
        popup.className = 'achievement-popup';
        popup.innerHTML = `<h3>${title}</h3><p>${message}</p>`;
        document.body.appendChild(popup);
        
        setTimeout(() => {
            popup.remove();
        }, 3000);
    }

    showCombo(text) {
        const combo = document.createElement('div');
        combo.className = 'combo-meter';
        combo.textContent = text;
        document.body.appendChild(combo);
        
        setTimeout(() => {
            combo.remove();
        }, 1000);
    }
}

class Task {
    constructor(name, arrival, burst, priority, category) {
        this.id = Date.now() + Math.random();
        this.name = name;
        this.arrivalTime = parseInt(arrival);
        this.burstTime = parseInt(burst);
        this.remainingTime = parseInt(burst);
        this.priority = parseInt(priority);
        this.category = category;
        this.waitingTime = 0;
        this.turnaroundTime = 0;
        this.completionTime = 0;
        this.startTime = -1;
        this.isCompleted = false;
    }
}

class CPUScheduler {
    constructor(gameManager) {
        this.tasks = [];
        this.ganttChart = [];
        this.currentTime = 0;
        this.isRunning = false;
        this.mode = 'non-preemptive';
        this.contextSwitches = 0;
        this.currentTask = null;
        this.gameManager = gameManager;
    }

    addTask(task) {
        this.tasks.push(task);
        this.tasks.sort((a, b) => {
            if (a.arrivalTime !== b.arrivalTime) return a.arrivalTime - b.arrivalTime;
            return a.priority - b.priority;
        });
        this.gameManager.addXP(10);
    }

    getReadyQueue(time) {
        return this.tasks.filter(t => 
            t.arrivalTime <= time && !t.isCompleted
        ).sort((a, b) => {
            if (a.priority !== b.priority) return a.priority - b.priority;
            return a.arrivalTime - b.arrivalTime;
        });
    }

    async execute() {
        this.isRunning = true;
        this.currentTime = 0;
        this.ganttChart = [];
        this.contextSwitches = 0;
        this.executionOrder = [];

        while (this.tasks.some(t => !t.isCompleted)) {
            const readyQueue = this.getReadyQueue(this.currentTime);

            if (readyQueue.length === 0) {
                this.currentTime++;
                continue;
            }

            const task = readyQueue[0];
            
            if (task.startTime === -1) {
                task.startTime = this.currentTime;
                // Track when task actually starts executing
                if (!this.executionOrder.find(e => e.id === task.id)) {
                    this.executionOrder.push({
                        id: task.id,
                        name: task.name,
                        priority: task.priority,
                        category: task.category,
                        startTime: this.currentTime
                    });
                }
            }

            if (this.currentTask && this.currentTask.id !== task.id) {
                this.contextSwitches++;
            }
            this.currentTask = task;

            this.updateUI(task);

            if (this.mode === 'non-preemptive') {
                await this.executeNonPreemptive(task);
            } else {
                await this.executePreemptive(task);
            }
        }

        this.isRunning = false;
        this.calculateMetrics();
        this.updateMetricsUI();
        this.showExecutionOrder();
        document.getElementById('cpuStatus').textContent = 'Execution Complete!';
        document.getElementById('cpuIcon').classList.remove('running');
        
        // Calculate bonus score based on performance
        const efficiency = parseFloat(this.metrics.cpuUtilization);
        if (efficiency > 90) {
            this.gameManager.showAchievement('Efficiency Master! ‚ö°', 'CPU utilization over 90%!');
            this.gameManager.addXP(100);
        } else if (efficiency > 75) {
            this.gameManager.addXP(50);
        }
    }

    async executeNonPreemptive(task) {
        const startTime = this.currentTime;
        
        while (task.remainingTime > 0) {
            await this.sleep(500);
            task.remainingTime--;
            this.currentTime++;
            this.updateGanttChart(task, startTime, this.currentTime);
        }

        task.isCompleted = true;
        task.completionTime = this.currentTime;
        task.turnaroundTime = task.completionTime - task.arrivalTime;
        task.waitingTime = task.turnaroundTime - task.burstTime;
        this.gameManager.completeTask();
    }

    async executePreemptive(task) {
        const startTime = this.currentTime;
        
        await this.sleep(500);
        task.remainingTime--;
        this.currentTime++;
        
        this.updateGanttChart(task, startTime, this.currentTime);

        if (task.remainingTime === 0) {
            task.isCompleted = true;
            task.completionTime = this.currentTime;
            task.turnaroundTime = task.completionTime - task.arrivalTime;
            task.waitingTime = task.turnaroundTime - task.burstTime;
            this.gameManager.completeTask();
        }
    }

    updateGanttChart(task, start, end) {
        const lastEntry = this.ganttChart[this.ganttChart.length - 1];
        
        if (lastEntry && lastEntry.taskId === task.id) {
            lastEntry.end = end;
        } else {
            this.ganttChart.push({
                taskId: task.id,
                taskName: task.name,
                priority: task.priority,
                start: start,
                end: end
            });
        }
        
        this.renderGanttChart();
    }

    updateUI(task) {
        document.getElementById('cpuStatus').textContent = `Executing: ${task.name}`;
        document.getElementById('currentTask').textContent = 
            `Priority: ${task.priority} | Remaining: ${task.remainingTime}ms`;
        document.getElementById('cpuIcon').classList.add('running');
        this.renderTaskQueue();
    }

    renderTaskQueue() {
        const queue = document.getElementById('taskQueue');
        if (this.tasks.length === 0) {
            queue.innerHTML = '<div class="empty-state">No tasks in queue. Add tasks above!</div>';
            return;
        }

        queue.innerHTML = this.tasks.map(task => `
            <div class="task-card ${task.isCompleted ? 'completed' : ''} ${
                this.currentTask && this.currentTask.id === task.id && !task.isCompleted ? 'executing' : ''
            }">
                <div class="task-info">
                    <h3>${task.category} ${task.name}</h3>
                    <div class="task-meta">
                        <span>Arrival: ${task.arrivalTime}</span>
                        <span>Burst: ${task.burstTime}</span>
                        <span>Remaining: ${task.remainingTime}</span>
                    </div>
                </div>
                <span class="priority-badge priority-${task.priority}">
                    P${task.priority}
                </span>
            </div>
        `).join('');
    }

    renderGanttChart() {
        const chart = document.getElementById('ganttChart');
        if (this.ganttChart.length === 0) {
            chart.innerHTML = '<div class="empty-state">Start execution to see timeline</div>';
            return;
        }

        const colors = {
            1: 'linear-gradient(45deg, #ef4444, #dc2626)',
            2: 'linear-gradient(45deg, #f59e0b, #d97706)',
            3: 'linear-gradient(45deg, #fbbf24, #f59e0b)',
            4: 'linear-gradient(45deg, #10b981, #059669)',
            5: 'linear-gradient(45deg, #3b82f6, #2563eb)'
        };

        chart.innerHTML = this.ganttChart.map((entry, idx) => {
            const width = (entry.end - entry.start) * 50;
            const isLast = idx === this.ganttChart.length - 1;
            return `
                <div class="gantt-bar ${isLast ? 'current' : ''}" 
                     style="width: ${width}px; background: ${colors[entry.priority]}; margin-right: 5px;">
                    ${entry.taskName}<br>
                    <small>P${entry.priority}</small>
                    <div class="time-label">${entry.start}-${entry.end}</div>
                </div>
            `;
        }).join('');
    }

    calculateMetrics() {
        const completedTasks = this.tasks.filter(t => t.isCompleted);
        const totalWaitTime = completedTasks.reduce((sum, t) => sum + t.waitingTime, 0);
        const totalTurnaround = completedTasks.reduce((sum, t) => sum + t.turnaroundTime, 0);
        const totalBurstTime = completedTasks.reduce((sum, t) => sum + t.burstTime, 0);

        this.metrics = {
            avgWaitTime: (totalWaitTime / completedTasks.length).toFixed(2),
            avgTurnaround: (totalTurnaround / completedTasks.length).toFixed(2),
            contextSwitches: this.contextSwitches,
            cpuUtilization: ((totalBurstTime / this.currentTime) * 100).toFixed(1)
        };
    }

    updateMetricsUI() {
        if (this.metrics) {
            document.getElementById('avgWaitTime').textContent = this.metrics.avgWaitTime;
            document.getElementById('avgTurnaround').textContent = this.metrics.avgTurnaround;
            document.getElementById('contextSwitches').textContent = this.metrics.contextSwitches;
            document.getElementById('cpuUtilization').textContent = this.metrics.cpuUtilization + '%';
        }
    }

    showExecutionOrder() {
        const panel = document.getElementById('executionOrderPanel');
        const list = document.getElementById('executionOrderList');
        
        panel.style.display = 'block';
        
        const priorityColors = {
            1: '#ef4444',
            2: '#f59e0b',
            3: '#fbbf24',
            4: '#10b981',
            5: '#3b82f6'
        };
        
        list.innerHTML = this.executionOrder.map((task, index) => `
            <div style="display: flex; align-items: center; gap: 20px; background: rgba(255,255,255,0.05); padding: 15px; border-radius: 10px; border-left: 5px solid ${priorityColors[task.priority]};">
                <div style="font-size: 2rem; font-weight: 900; color: ${priorityColors[task.priority]}; min-width: 40px;">
                    ${index + 1}
                </div>
                <div style="flex: 1;">
                    <div style="font-size: 1.2rem; font-weight: 600; margin-bottom: 5px;">
                        ${task.category} ${task.name}
                    </div>
                    <div style="opacity: 0.8; font-size: 0.9rem;">
                        Started at time: ${task.startTime}ms
                    </div>
                </div>
                <div style="background: ${priorityColors[task.priority]}; padding: 8px 20px; border-radius: 20px; font-weight: 700; font-size: 1.1rem;">
                    P${task.priority}
                </div>
            </div>
        `).join('');
    }

    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }

    reset() {
        this.tasks = [];
        this.ganttChart = [];
        this.currentTime = 0;
        this.isRunning = false;
        this.contextSwitches = 0;
        this.currentTask = null;
        this.executionOrder = [];
        
        document.getElementById('ganttChart').innerHTML = 
            '<div class="empty-state">Start execution to see timeline</div>';
        document.getElementById('cpuStatus').textContent = 'CPU Idle';
        document.getElementById('currentTask').textContent = 'Waiting for tasks...';
        document.getElementById('cpuIcon').classList.remove('running');
        document.getElementById('executionOrderPanel').style.display = 'none';
        
        this.renderTaskQueue();
        this.metrics = null;
        document.getElementById('avgWaitTime').textContent = '0';
        document.getElementById('avgTurnaround').textContent = '0';
        document.getElementById('contextSwitches').textContent = '0';
        document.getElementById('cpuUtilization').textContent = '0%';
        
        this.gameManager.resetStreak();
    }
}

const gameManager = new GameManager();
const scheduler = new CPUScheduler(gameManager);

document.getElementById('addTaskBtn').addEventListener('click', () => {
    const name = document.getElementById('taskName').value.trim();
    const arrival = document.getElementById('arrivalTime').value;
    const burst = document.getElementById('burstTime').value;
    const priority = document.getElementById('priority').value;
    const category = document.getElementById('category').value;

    if (!name) {
        alert('Please enter a task name!');
        return;
    }

    const task = new Task(name, arrival, burst, priority, category);
    scheduler.addTask(task);
    scheduler.renderTaskQueue();

    document.getElementById('taskName').value = '';
    document.getElementById('arrivalTime').value = parseInt(arrival) + 1;
});

document.getElementById('startBtn').addEventListener('click', () => {
    if (scheduler.tasks.length === 0) {
        alert('Please add tasks before starting execution!');
        return;
    }
    
    if (!scheduler.isRunning) {
        document.getElementById('startBtn').disabled = true;
        scheduler.execute().then(() => {
            document.getElementById('startBtn').disabled = false;
        });
    }
});

document.getElementById('resetBtn').addEventListener('click', () => {
    scheduler.reset();
});

document.querySelectorAll('.mode-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        document.querySelectorAll('.mode-btn').forEach(b => b.classList.remove('active'));
        btn.classList.add('active');
        scheduler.mode = btn.dataset.mode;
    });
});

document.getElementById('taskName').addEventListener('keypress', (e) => {
    if (e.key === 'Enter') {
        document.getElementById('addTaskBtn').click();
    }
});
    </script>
</body>
</html>